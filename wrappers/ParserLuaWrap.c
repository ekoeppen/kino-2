/*
 * FILE : ParserLuaWrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : Lua */

#include <lua.h>

/*****************************************************************************
 * $Header:$
 *
 * swigptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is typically used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer which is assumed to hold enough space for the result.
 *
 * char * SWIG_GetPtr(char *buffer, void **ptr, char *type)
 *
 *      Gets a pointer value from a string.  If there is a type-mismatch, returns
 *      a character string to the received type.  On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif


/* SWIG pointer structure */

typedef struct SwigPtrType {
  char               *name;               /* Datatype name                  */
  int                 len;                /* Length (used for optimization) */
  void               *(*cast)(void *);    /* Pointer casting function       */
  struct SwigPtrType *next;               /* Linked list pointer            */
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

/* Some variables  */

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
                                       /* This value may be adjusted dynamically */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static int SwigStart[256];             /* Starting positions of types            */

/* Pointer table */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {

  int i;
  SwigPtrType *t = 0,*t1;

  /* Allocate the pointer table if necessary */

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  /* Grow the table */
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc((char *) SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }

  /* Check for existing entry */

  while (t->next) {
    if ((strcmp(t->name,newtype) == 0)) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  
  /* Now place entry (in sorted order) */

  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;            
  t->next = t1;           
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

SWIGSTATIC 
char *SWIG_GetPtr(char *_c, void **ptr, char *_t)
{
  unsigned long _p;
  char temp_type[256];
  char *name;
  int  i, len;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;
  int  start, end;
  _p = 0;

  /* Pointer values must start with leading underscore */
  if (*_c == '_') {
      _c++;
      /* Extract hex value from pointer */
      while (*_c) {
	  if ((*_c >= '0') && (*_c <= '9'))
	    _p = (_p << 4) + (*_c - '0');
	  else if ((*_c >= 'a') && (*_c <= 'f'))
	    _p = (_p << 4) + ((*_c - 'a') + 10);
	  else
	    break;
	  _c++;
      }

      if (_t) {
	if (strcmp(_t,_c)) { 
	  if (!SwigPtrSort) {
	    qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort); 
	    for (i = 0; i < 256; i++) {
	      SwigStart[i] = SwigPtrN;
	    }
	    for (i = SwigPtrN-1; i >= 0; i--) {
	      SwigStart[(int) (SwigPtrTable[i].name[1])] = i;
	    }
	    for (i = 255; i >= 1; i--) {
	      if (SwigStart[i-1] > SwigStart[i])
		SwigStart[i-1] = SwigStart[i];
	    }
	    SwigPtrSort = 1;
	    for (i = 0; i < SWIG_CACHESIZE; i++)  
	      SwigCache[i].stat = 0;
	  }
	  
	  /* First check cache for matches.  Uses last cache value as starting point */
	  cache = &SwigCache[SwigLastCache];
	  for (i = 0; i < SWIG_CACHESIZE; i++) {
	    if (cache->stat) {
	      if (strcmp(_t,cache->name) == 0) {
		if (strcmp(_c,cache->mapped) == 0) {
		  cache->stat++;
		  *ptr = (void *) _p;
		  if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
		  return (char *) 0;
		}
	      }
	    }
	    SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	    if (!SwigLastCache) cache = SwigCache;
	    else cache++;
	  }
	  /* We have a type mismatch.  Will have to look through our type
	     mapping table to figure out whether or not we can accept this datatype */

	  start = SwigStart[(int) _t[1]];
	  end = SwigStart[(int) _t[1]+1];
	  sp = &SwigPtrTable[start];
	  while (start < end) {
	    if (swigcmp(_t,sp) == 0) break;
	    sp++;
	    start++;
	  }
	  if (start >= end) sp = 0;
	  /* Try to find a match for this */
	  if (sp) {
	    while (swigcmp(_t,sp) == 0) {
	      name = sp->name;
	      len = sp->len;
	      tp = sp->next;
	      /* Try to find entry for our given datatype */
	      while(tp) {
		if (tp->len >= 255) {
		  return _c;
		}
		strcpy(temp_type,tp->name);
		strncat(temp_type,_t+len,255-tp->len);
		if (strcmp(_c,temp_type) == 0) {
		  
		  strcpy(SwigCache[SwigCacheIndex].mapped,_c);
		  strcpy(SwigCache[SwigCacheIndex].name,_t);
		  SwigCache[SwigCacheIndex].stat = 1;
		  SwigCache[SwigCacheIndex].tp = tp;
		  SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
		  
		  /* Get pointer value */
		  *ptr = (void *) _p;
		  if (tp->cast) *ptr = (*(tp->cast))(*ptr);
		  return (char *) 0;
		}
		tp = tp->next;
	      }
	      sp++;
	      /* Hmmm. Didn't find it this time */
	    }
	  }
	  /* Didn't find any sort of match for this data.  
	     Get the pointer value and return the received type */
	  *ptr = (void *) _p;
	  return _c;
	} else {
	  /* Found a match on the first try.  Return pointer value */
	  *ptr = (void *) _p;
	  return (char *) 0;
	}
      } else {
	/* No type specified.  Good luck */
	*ptr = (void *) _p;
	return (char *) 0;
      }
  } else {
    if (strcmp (_c, "NULL") == 0) {
	*ptr = (void *) 0;
	return (char *) 0;
    }
    *ptr = (void *) 0;	
    return _c;
  }
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr


#ifdef NATIVE_NETWORKING
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <netdb.h>
#include <regex.h>

#ifdef HAVE_LIBPTHREAD
#include <pthread.h>
#endif

#include <Net.h>
#endif

#include <KinoParser.h>
#include <AHDRuntime.h>

static void _wrap_NodeNew(void) {

    Node * _result;

    _result = (Node *)NodeNew();
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_ElementNew(void) {

    Element * _result;

    _result = (Element *)ElementNew();
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_DocumentNew(void) {

    Document * _result;

    _result = (Document *)DocumentNew();
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_TextNew(void) {

    Text * _result;

    _result = (Text *)TextNew();
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_InsetNew(void) {

    Inset * _result;

    _result = (Inset *)InsetNew();
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_CDATASectionNew(void) {

    CDATASection * _result;

    _result = (CDATASection *)CDATASectionNew();
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeDelete(void) {

    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    NodeDelete(_arg0);
    
}
static void _wrap_NodeGetNodeType(void) {

    int  _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (int )NodeGetNodeType(_arg0);
{
  lua_pushnumber ((double) _result);
}
    
}
static void _wrap_NodeGetParentNode(void) {

    Node * _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (Node *)NodeGetParentNode(_arg0);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeGetOwnerDocument(void) {

    Document * _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (Document *)NodeGetOwnerDocument(_arg0);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeGetPreviousSibling(void) {

    Node * _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (Node *)NodeGetPreviousSibling(_arg0);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeGetNextSibling(void) {

    Node * _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (Node *)NodeGetNextSibling(_arg0);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeHasChildNodes(void) {

    int  _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (int )NodeHasChildNodes(_arg0);
{
  lua_pushnumber ((double) _result);
}
    
}
static void _wrap_NodeGetFirstChild(void) {

    Node * _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (Node *)NodeGetFirstChild(_arg0);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeGetLastChild(void) {

    Node * _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (Node *)NodeGetLastChild(_arg0);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeAppendChild(void) {

    Node * _arg0;
    Node * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
    NodeAppendChild(_arg0,_arg1);
    
}
static void _wrap_NodeInsertBefore(void) {

    Node * _arg0;
    Node * _arg1;
    Node * _arg2;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
{
  if (!lua_isnil (lua_getparam (3))) _arg2 = lua_getuserdata (lua_getparam (3));
  else _arg2 = NULL;
}
    NodeInsertBefore(_arg0,_arg1,_arg2);
    
}
static void _wrap_NodeReplaceChild(void) {

    Node * _result;
    Node * _arg0;
    Node * _arg1;
    Node * _arg2;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
{
  if (!lua_isnil (lua_getparam (3))) _arg2 = lua_getuserdata (lua_getparam (3));
  else _arg2 = NULL;
}
    _result = (Node *)NodeReplaceChild(_arg0,_arg1,_arg2);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeRemoveChild(void) {

    Node * _result;
    Node * _arg0;
    Node * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
    _result = (Node *)NodeRemoveChild(_arg0,_arg1);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodePrint(void) {

    Node * _arg0;
    int  _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = (int ) lua_getnumber (lua_getparam (2));
}
    NodePrint(_arg0,_arg1);
    
}
static void _wrap_NodeToText(void) {

    char * _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (char *)NodeToText(_arg0);
{
  lua_pushstring (_result);
}
{
	free (_result);
}
    
}
static void _wrap_NodeParentLookup(void) {

    Node * _result;
    Node * _arg0;
    char * _arg1;
    char * _arg2;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
{
  _arg2 = lua_getstring (lua_getparam (3));
}
    _result = (Node *)NodeParentLookup(_arg0,_arg1,_arg2);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeChildLookup(void) {

    Node * _result;
    Node * _arg0;
    char * _arg1;
    char * _arg2;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
{
  _arg2 = lua_getstring (lua_getparam (3));
}
    _result = (Node *)NodeChildLookup(_arg0,_arg1,_arg2);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeGetSuccessor(void) {

    Node * _result;
    Node * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (Node *)NodeGetSuccessor(_arg0);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_TextGetData(void) {

    char * _result;
    Text * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (char *)TextGetData(_arg0);
{
  lua_pushstring (_result);
}
    
}
static void _wrap_TextSetData(void) {

    Text * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    TextSetData(_arg0,_arg1);
    
}
static void _wrap_CDATASectionGetData(void) {

    char * _result;
    CDATASection * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (char *)CDATASectionGetData(_arg0);
{
  lua_pushstring (_result);
}
    
}
static void _wrap_CDATASectionSetData(void) {

    CDATASection * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    CDATASectionSetData(_arg0,_arg1);
    
}
static void _wrap_DocumentGetElementsByTagName(void) {

    NodeList * _result;
    Document * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    _result = (NodeList *)DocumentGetElementsByTagName(_arg0,_arg1);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_ElementGetTagName(void) {

    char * _result;
    Element * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (char *)ElementGetTagName(_arg0);
{
  lua_pushstring (_result);
}
    
}
static void _wrap_ElementSetTagName(void) {

    Element * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    ElementSetTagName(_arg0,_arg1);
    
}
static void _wrap_ElementGetNSPrefix(void) {

    char * _result;
    Element * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (char *)ElementGetNSPrefix(_arg0);
{
  lua_pushstring (_result);
}
    
}
static void _wrap_ElementSetNSPrefix(void) {

    Element * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    ElementSetNSPrefix(_arg0,_arg1);
    
}
static void _wrap_ElementGetAttribute(void) {

    char * _result;
    Element * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    _result = (char *)ElementGetAttribute(_arg0,_arg1);
{
  lua_pushstring (_result);
}
    
}
static void _wrap_ElementSetAttribute(void) {

    Element * _arg0;
    char * _arg1;
    char * _arg2;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
{
  _arg2 = lua_getstring (lua_getparam (3));
}
    ElementSetAttribute(_arg0,_arg1,_arg2);
    
}
static void _wrap_ElementSetContents(void) {

    Element * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    ElementSetContents(_arg0,_arg1);
    
}
static void _wrap_ElementGetContents(void) {

    char * _result;
    Element * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (char *)ElementGetContents(_arg0);
{
  lua_pushstring (_result);
}
{
	free (_result);
}
    
}
static void _wrap_ElementSetDefaultAttributes(void) {

    Element * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    ElementSetDefaultAttributes(_arg0);
    
}
static void _wrap_ElementSetInherited(void) {

    Element * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    ElementSetInherited(_arg0);
    
}
static void _wrap_ElementGetElementsByTagName(void) {

    NodeList * _result;
    Element * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    _result = (NodeList *)ElementGetElementsByTagName(_arg0,_arg1);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeListNew(void) {

    NodeList * _result;

    _result = (NodeList *)NodeListNew();
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeListDelete(void) {

    NodeList * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    NodeListDelete(_arg0);
    
}
static void _wrap_NodeListAppendItem(void) {

    int  _result;
    NodeList * _arg0;
    Node * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
    _result = (int )NodeListAppendItem(_arg0,_arg1);
{
  lua_pushnumber ((double) _result);
}
    
}
static void _wrap_NodeListGetLength(void) {

    int  _result;
    NodeList * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    _result = (int )NodeListGetLength(_arg0);
{
  lua_pushnumber ((double) _result);
}
    
}
static void _wrap_NodeListGetItem(void) {

    Node * _result;
    NodeList * _arg0;
    int  _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = (int ) lua_getnumber (lua_getparam (2));
}
    _result = (Node *)NodeListGetItem(_arg0,_arg1);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_NodeListRemoveItem(void) {

    Node * _result;
    NodeList * _arg0;
    Node * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
    _result = (Node *)NodeListRemoveItem(_arg0,_arg1);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_ElementMatch(void) {

    NodeList * _result;
    Element * _arg0;
    Element * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
    _result = (NodeList *)ElementMatch(_arg0,_arg1);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_ParserNew(void) {

    Parser * _result;

    _result = (Parser *)ParserNew();
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
static void _wrap_ParserDelete(void) {

    Parser * _arg0;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
    ParserDelete(_arg0);
    
}
static void _wrap_ParserSetStartElement(void) {

    Parser * _arg0;
    Element * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
    ParserSetStartElement(_arg0,_arg1);
    
}
static void _wrap_ParserSetDocument(void) {

    Parser * _arg0;
    Document * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  if (!lua_isnil (lua_getparam (2))) _arg1 = lua_getuserdata (lua_getparam (2));
  else _arg1 = NULL;
}
    ParserSetDocument(_arg0,_arg1);
    
}
static void _wrap_ParserSetURI(void) {

    Parser * _arg0;
    char * _arg1;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
    ParserSetURI(_arg0,_arg1);
    
}
static void _wrap_ParserProcessData(void) {

    Element * _result;
    Parser * _arg0;
    char * _arg1;
    char * _arg2;

{
  if (!lua_isnil (lua_getparam (1))) _arg0 = lua_getuserdata (lua_getparam (1));
  else _arg0 = NULL;
}
{
  _arg1 = lua_getstring (lua_getparam (2));
}
{
  _arg2 = lua_getstring (lua_getparam (3));
}
    _result = (Element *)ParserProcessData(_arg0,_arg1,_arg2);
{
  if (_result != NULL) lua_pushuserdata (_result);
  else lua_pushnil ();
}
    
}
void kinoparserlua_init (void) {
	 lua_register ("NodeNew",_wrap_NodeNew);
	 lua_register ("ElementNew",_wrap_ElementNew);
	 lua_register ("DocumentNew",_wrap_DocumentNew);
	 lua_register ("TextNew",_wrap_TextNew);
	 lua_register ("InsetNew",_wrap_InsetNew);
	 lua_register ("CDATASectionNew",_wrap_CDATASectionNew);
	 lua_register ("NodeDelete",_wrap_NodeDelete);
	 lua_register ("NodeGetNodeType",_wrap_NodeGetNodeType);
	 lua_register ("NodeGetParentNode",_wrap_NodeGetParentNode);
	 lua_register ("NodeGetOwnerDocument",_wrap_NodeGetOwnerDocument);
	 lua_register ("NodeGetPreviousSibling",_wrap_NodeGetPreviousSibling);
	 lua_register ("NodeGetNextSibling",_wrap_NodeGetNextSibling);
	 lua_register ("NodeHasChildNodes",_wrap_NodeHasChildNodes);
	 lua_register ("NodeGetFirstChild",_wrap_NodeGetFirstChild);
	 lua_register ("NodeGetLastChild",_wrap_NodeGetLastChild);
	 lua_register ("NodeAppendChild",_wrap_NodeAppendChild);
	 lua_register ("NodeInsertBefore",_wrap_NodeInsertBefore);
	 lua_register ("NodeReplaceChild",_wrap_NodeReplaceChild);
	 lua_register ("NodeRemoveChild",_wrap_NodeRemoveChild);
	 lua_register ("NodePrint",_wrap_NodePrint);
	 lua_register ("NodeToText",_wrap_NodeToText);
	 lua_register ("NodeParentLookup",_wrap_NodeParentLookup);
	 lua_register ("NodeChildLookup",_wrap_NodeChildLookup);
	 lua_register ("NodeGetSuccessor",_wrap_NodeGetSuccessor);
	 lua_register ("TextGetData",_wrap_TextGetData);
	 lua_register ("TextSetData",_wrap_TextSetData);
	 lua_register ("CDATASectionGetData",_wrap_CDATASectionGetData);
	 lua_register ("CDATASectionSetData",_wrap_CDATASectionSetData);
	 lua_register ("DocumentGetElementsByTagName",_wrap_DocumentGetElementsByTagName);
	 lua_register ("ElementGetTagName",_wrap_ElementGetTagName);
	 lua_register ("ElementSetTagName",_wrap_ElementSetTagName);
	 lua_register ("ElementGetNSPrefix",_wrap_ElementGetNSPrefix);
	 lua_register ("ElementSetNSPrefix",_wrap_ElementSetNSPrefix);
	 lua_register ("ElementGetAttribute",_wrap_ElementGetAttribute);
	 lua_register ("ElementSetAttribute",_wrap_ElementSetAttribute);
	 lua_register ("ElementSetContents",_wrap_ElementSetContents);
	 lua_register ("ElementGetContents",_wrap_ElementGetContents);
	 lua_register ("ElementSetDefaultAttributes",_wrap_ElementSetDefaultAttributes);
	 lua_register ("ElementSetInherited",_wrap_ElementSetInherited);
	 lua_register ("ElementGetElementsByTagName",_wrap_ElementGetElementsByTagName);
	 lua_register ("NodeListNew",_wrap_NodeListNew);
	 lua_register ("NodeListDelete",_wrap_NodeListDelete);
	 lua_register ("NodeListAppendItem",_wrap_NodeListAppendItem);
	 lua_register ("NodeListGetLength",_wrap_NodeListGetLength);
	 lua_register ("NodeListGetItem",_wrap_NodeListGetItem);
	 lua_register ("NodeListRemoveItem",_wrap_NodeListRemoveItem);
	 lua_register ("ElementMatch",_wrap_ElementMatch);
	 lua_register ("ParserNew",_wrap_ParserNew);
	 lua_register ("ParserDelete",_wrap_ParserDelete);
	 lua_register ("ParserSetStartElement",_wrap_ParserSetStartElement);
	 lua_register ("ParserSetDocument",_wrap_ParserSetDocument);
	 lua_register ("ParserSetURI",_wrap_ParserSetURI);
	 lua_register ("ParserProcessData",_wrap_ParserProcessData);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("_signed_long","_long",0);
	 SWIG_RegisterMapping("_long","_unsigned_long",0);
	 SWIG_RegisterMapping("_long","_signed_long",0);
	 SWIG_RegisterMapping("_unsigned_long","_long",0);
	 SWIG_RegisterMapping("_signed_int","_int",0);
	 SWIG_RegisterMapping("_unsigned_short","_short",0);
	 SWIG_RegisterMapping("_signed_short","_short",0);
	 SWIG_RegisterMapping("_unsigned_int","_int",0);
	 SWIG_RegisterMapping("_short","_unsigned_short",0);
	 SWIG_RegisterMapping("_short","_signed_short",0);
	 SWIG_RegisterMapping("_int","_unsigned_int",0);
	 SWIG_RegisterMapping("_int","_signed_int",0);
}
